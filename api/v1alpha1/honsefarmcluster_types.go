package v1alpha1

import (
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
    "k8s.io/apimachinery/pkg/runtime"
)

// HonseFarmClusterSpec defines the desired state of HonseFarmCluster
type HonseFarmClusterSpec struct {
    // Namespace where HonseFarm components should be deployed
    Namespace string `json:"namespace"`

    // Base DNS name used for the cluster entrypoint (e.g. cluster.honse.farm)
    APIDomain string `json:"apiDomain"`

    // Container registry (e.g. ghcr.io/dorbian)
    Registry string `json:"registry,omitempty"`

    // Images for the HonseFarm services
    Images HonseFarmImages `json:"images,omitempty"`

    // Cloudflared configuration for exposing services externally
    Cloudflared *CloudflaredSpec `json:"cloudflared,omitempty"`
}

type HonseFarmImages struct {
    Server         string `json:"server,omitempty"`
    MainFileserver string `json:"mainFileserver,omitempty"`
    ShardFileserver string `json:"shardFileserver,omitempty"`
    AdminPanel     string `json:"adminPanel,omitempty"`
    Observability  string `json:"observability,omitempty"`
}

// CloudflaredSpec configures a Cloudflare tunnel
type CloudflaredSpec struct {
    Enabled bool `json:"enabled"`

    // Cloudflared image to use
    Image string `json:"image,omitempty"`

    // Human-readable name of the tunnel
    TunnelName string `json:"tunnelName,omitempty"`

    // UUID of the tunnel
    TunnelID string `json:"tunnelId,omitempty"`

    // Reference to credentials secret
    CredentialsSecretRef *SecretRef `json:"credentialsSecretRef,omitempty"`

    // Additional CLI args
    ExtraArgs []string `json:"extraArgs,omitempty"`

    // Ingress rules mapping hostnames to services
    Ingress []CloudflaredIngressRule `json:"ingress,omitempty"`
}

type SecretRef struct {
    Name      string `json:"name"`
    Namespace string `json:"namespace,omitempty"`
}

type CloudflaredIngressRule struct {
    Hostname         string `json:"hostname,omitempty"`
    ServiceName      string `json:"serviceName,omitempty"`
    ServiceNamespace string `json:"serviceNamespace,omitempty"`
    ServicePort      int32  `json:"servicePort,omitempty"`
    SpecialService   string `json:"specialService,omitempty"`
}

// HonseFarmClusterStatus defines the observed state of HonseFarmCluster
type HonseFarmClusterStatus struct {
    Phase             string             `json:"phase,omitempty"`
    Conditions        []metav1.Condition `json:"conditions,omitempty"`
    CloudflaredStatus *CloudflaredStatus `json:"cloudflaredStatus,omitempty"`
}

type CloudflaredStatus struct {
    Ready     bool   `json:"ready,omitempty"`
    LastError string `json:"lastError,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// HonseFarmCluster is the Schema for the honsefarmclusters API
type HonseFarmCluster struct {
    metav1.TypeMeta   `json:",inline"`
    metav1.ObjectMeta `json:"metadata,omitempty"`

    Spec   HonseFarmClusterSpec   `json:"spec,omitempty"`
    Status HonseFarmClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// HonseFarmClusterList contains a list of HonseFarmCluster
type HonseFarmClusterList struct {
    metav1.TypeMeta `json:",inline"`
    metav1.ListMeta `json:"metadata,omitempty"`
    Items           []HonseFarmCluster `json:"items"`
}

// DeepCopyInto copies all properties of this object into another object of the
// same type that is provided as a argument.
func (in *HonseFarmCluster) DeepCopyInto(out *HonseFarmCluster) {
    *out = *in
    out.TypeMeta = in.TypeMeta
    in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)

    // Deep copy Conditions slice
    if in.Status.Conditions != nil {
        out.Status.Conditions = make([]metav1.Condition, len(in.Status.Conditions))
        for i := range in.Status.Conditions {
            in.Status.Conditions[i].DeepCopyInto(&out.Status.Conditions[i])
        }
    }
    if in.Status.CloudflaredStatus != nil {
        out.Status.CloudflaredStatus = &CloudflaredStatus{
            Ready:     in.Status.CloudflaredStatus.Ready,
            LastError: in.Status.CloudflaredStatus.LastError,
        }
    }

    // Deep copy Cloudflared spec slice
    if in.Spec.Cloudflared != nil {
        cfIn := in.Spec.Cloudflared
        cfOut := new(CloudflaredSpec)
        *cfOut = *cfIn
        if cfIn.CredentialsSecretRef != nil {
            cfOut.CredentialsSecretRef = &SecretRef{
                Name:      cfIn.CredentialsSecretRef.Name,
                Namespace: cfIn.CredentialsSecretRef.Namespace,
            }
        }
        if cfIn.Ingress != nil {
            cfOut.Ingress = make([]CloudflaredIngressRule, len(cfIn.Ingress))
            copy(cfOut.Ingress, cfIn.Ingress)
        }
        out.Spec.Cloudflared = cfOut
    }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HonseFarmCluster.
func (in *HonseFarmCluster) DeepCopy() *HonseFarmCluster {
    if in == nil {
        return nil
    }
    out := new(HonseFarmCluster)
    in.DeepCopyInto(out)
    return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *HonseFarmCluster) DeepCopyObject() runtime.Object {
    if c := in.DeepCopy(); c != nil {
        return c
    }
    return nil
}

// DeepCopyInto for list
func (in *HonseFarmClusterList) DeepCopyInto(out *HonseFarmClusterList) {
    *out = *in
    out.TypeMeta = in.TypeMeta
    in.ListMeta.DeepCopyInto(&out.ListMeta)
    if in.Items != nil {
        out.Items = make([]HonseFarmCluster, len(in.Items))
        for i := range in.Items {
            in.Items[i].DeepCopyInto(&out.Items[i])
        }
    }
}

// DeepCopy creates a new deep-copied list.
func (in *HonseFarmClusterList) DeepCopy() *HonseFarmClusterList {
    if in == nil {
        return nil
    }
    out := new(HonseFarmClusterList)
    in.DeepCopyInto(out)
    return out
}

// DeepCopyObject for list
func (in *HonseFarmClusterList) DeepCopyObject() runtime.Object {
    if c := in.DeepCopy(); c != nil {
        return c
    }
    return nil
}

func init() {
    SchemeBuilder.Register(&HonseFarmCluster{}, &HonseFarmClusterList{})
}
